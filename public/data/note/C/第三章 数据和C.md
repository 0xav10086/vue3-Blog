# 示例程序

```
/* platinum.c  -- your weight in platinum */
#include <stdio.h>
int main(void)
{
     float weight;    /* 你的体重                */
     float value;     /* 相等重量的白金价值        */

     printf("Are you worth your weight in platinum?\n");
     printf("Let's check it out.\n");
     printf("Please enter your weight in pounds: ");

     /* 获取用户的输入                        */
     scanf("%f", &weight);
     /* 假设白金的价格是每盎司$1700             */
     /* 14.5833用于把英磅常衡盎司转换为金衡盎司![](https://img30.360buyimg.com/ebookadmin/jfs/t1/105999/18/22490/1481/61ee3f2eE1038053c/5ae4f319f21f7a03.png)*/
     value = 1700.0 * weight * 14.5833;
     printf("Your weight in platinum is worth $%.2f.\n", value);
     printf("You are easily worth that! If platinum prices drop,\n");
     printf("eat more to maintain your value.\n");

     return 0;
}
```

以下为输出示例：

```
Are you worth your weight in platinum?
Let's check it out.
Please enter your weight in pounds: **156**
Your weight in platinum is worth $3867491.25.
You are easily worth that! If platinum prices drop,
eat more to maintain your value.
```

# 原码、反码和补码
## 原码
<p>上面我们说了实际上所有的数字都是使用0和1这样的二进制数来进行表示的，但是这样仅仅只能保存正数，那么负数怎么办呢？</p>
比如现在一共有4个bit位来保存我们的数据，为了表示正负，我们可以让第一个bit位专门来保存符号，这样，我们这4个bit位能够表示的数据范围就是：

最小：1111 => - (2^2+2^1+2^0) => -7 <br>
最大：0111 => + (2^2+2^1+2^0) => +7 => 7

虽然原码表示简单，但是原码在做加减法的时候，很麻烦！

以4bit位为例：<br>
1+(-1) = 0001 + 1001 = 
<br>
怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道，计算机顶多知道1+1需要进位！）
我们得创造一种更好的表示方式！于是我们引入了反码
## 反码
正数的反码是其本身
负数的反码是在其原码的基础上, 符号位不变，其余各个位取反
经过上面的定义，我们再来进行加减法：

1+(-1) = 0001 + 1110 = 1111 => -0 （直接相加，这样就简单多了！）

思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？
0既不是正数也不是负数，那么显然这样的表示依然不够合理！
## 补码
根据上面的问题，我们引入了最终的解决方案，那就是补码，定义如下：<br>
正数的补码就是其本身 （不变！）<br>
负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)<br>
其实现在就已经能够想通了，-0其实已经被消除了！我们再来看上面的运算：
1+(-1) = 0001 + 1111 = (1)0000 => +0 （现在无论你怎么算，也不会有-0了！）<br>
所以现在，4bit位能够表示的范围是：-8~+7（C使用的就是补码！）

# 变量与常量数据

为了让计算机完成任务，程序需要使用==数据==，即承载信息的数字和字符。有些数据类型在程序使用之前已经预先设定好了，在整个程序的运行过程中没有变化，这些称为**常量**（constant）。其他数据类型在程序运行期间可能会改变或被赋值，这些称为**变量**（variable）。

变量的名称并不是随便什么都可以的，它有以下规则：

- 不能重复使用其他变量使用过的名字。
- 只能包含英文字母或是下划线、数字，并且严格区分大小写，比如a和A不算同一个变量。
- 虽然可以包含数字，但是不能以数字开头。
- 不能是关键字（比如我们上面提到的所有基本数据类型，当然还有一些关键字我们会在后面认识）
- （建议）使用英文单词，不要使用拼音，多个词可以使用驼峰命名法或是通过下划线连接。
# 数据：数据类型关键字

在C语言中，用int关键字来表示基本的整数类型；char关键字用于指定字母和其他字符（如，#、$、%和*），也可以表示较小的整数；float、double和long double表示带小数点的数；Bool类型表示布尔值（true或false）；Complex和_Imaginary分别表示复数和虚数。

通过这些关键字创建的类型，按计算机的存储方式可分为两大基本类型：整数类型和浮点数类型。

## 位、字节和字

位、字节和字是描述计算机数据单元或存储单元的术语。这里主要指存储单元。

最小的存储单元是位（bit），可以存储0或1（或者说，位用于设置“开”或“关”）。

位是计算机内存的基本构建块。

字节（byte）是常用的计算机存储单位。对于几乎所有的机器，1字节均为8位。

字（word）是设计计算机时给定的自然存储单位。

# 整数和浮点数

## 整数

在C语言中，**整数**是没有小数部分的数。

计算机以二进制数字存储整数，例如，整数7以二进制写是111。

整数包含以下几种类型：

- int - 占用 4 个字节，32个bit位，能够表示 -2,147,483,648 到 2,147,483,647 之间的数字，默认一般都是使用这种类型
- long - 占用 8 个字节，64个bit位。
- short - 占用2个字节，16个bit位。

## 浮点
浮点类一般用于保存小数。

- float - 单精度浮点，占用4个字节，32个bit位。
- double - 双精度浮点，占用8个字节，64个bit位。

# 字符类型
除了保存数字之外，C语言还支持字符类型，我们的每一个字符都可以使用字符类型来保存：

- char - 占用1个字节（-128~127），可以表示所有的ASCII码字符，每一个数字对应的是编码表中的一个字符

# 格式控制符
|  格式控制符  | 说明         |
|  ----  |------------|
| %c	  | 输出一个单一的字符  |
| %hd、%d、%ld  | 以十进制、有符号的形式输出 short、int、long 类型的整数       |
|%hu、%u、%lu |以十进制、无符号的形式输出 short、int、long 类型的整数 |
|%ho、%o、%lo|以八进制、不带前缀、无符号的形式输出 short、int、long 类型的整数|
|%#ho、%#o、%#lo|以八进制、带前缀、无符号的形式输出 short、int、long 类型的整数|
|%hx、%x、%lx %hX、%X、%lX|以十六进制、不带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字也小写；如果 X 大写，那么输出的十六进制数字也大写。|
|%#hx、%#x、%#lx %#hX、%#X、%#lX|以十六进制、带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字和前缀都小写；如果 X 大写，那么输出的十六进制数字和前缀都大写。|
|%f、%lf|以十进制的形式输出 float、double 类型的小数|
|%e、%le %E、%lE|以指数的形式输出 float、double 类型的小数。如果 e 小写，那么输出结果中的 e 也小写；如果 E 大写，那么输出结果中的 E 也大写。|
|%g、%lg %G、%lG|以十进制和指数中较短的形式输出 float、double 类型的小数，并且小数部分的最后不会添加多余的 0。如果 g 小写，那么当以指数形式输出时 e 也小写；如果 G 大写，那么当以指数形式输出时 E 也大写。|
|%s|输出一个字符串|

# 运算结果溢出
```C
#include <stdio.h>

int main() {
    char c = 127;    //已经到达c的最大值了
    c = c + 1;   //我不管，我就要再加
    printf("%d", c);    //这时会得到什么结果？
}
```
```output
-128
```
由于位数不够，导致运算结果值溢出：

127 + 1= 01111111 + 1<br>
由于现在是二进制，满2进1，所以最后变成<br>
10000000 = 补码形式的 -128

# 无符号数
所有的数据底层都是采用二进制来进行保存的，而第一位则是用于保存符号位，但是如果我们不考虑这个符号位，那么所有的数都是按照正数来表示，比如考虑了符号位的char类型：

考虑符号表示范围：-128~127<br>
不考虑符号：0~255<br>
我们也可以直接使用这些不带符号位的数据类型：<br>
```C
int main() {
    unsigned char c = -65;   //数据类型前面添加unsigned关键字表示采用无符号形式
    printf("%u", c);    //%u以无符号形式输出十进制数据
}
```
```output
191
```
可以看到这里给了无符号char类型c一个-65的值，但是现在很明显符号位也是作为数值的表示部分，所以结果肯定不是-65：

我们来看看为什么得到的是191这个数字。首先char类型占据一个字节，8个bit位：

00000000 -> 现在赋值-65 -> -65的补码形式 -> 10111111<br>
由于现在没有符号位，一律都是正数，所以，10111111 = 128 + 32 + 16 + 8 + 4 + 2 + 1 = 191

我们也可以直接以无符号数形式打印：
```C
#include <stdio.h>

int main() {
    int i = -1;
    printf("%u", i);    //%u以无符号形式输出十进制数据
}
```
```output
4294967295
```
得到无符号int的最大值。

# 类型转换
一种类型的数据可以转换为其他类型的数据，这种操作我们称为类型转换，类型转换分为**自动类型转换**和**强制类型转换**。<br>
## 自动类型转换
我们现在希望将一个short类型的数据转换为int类型的数据：
```C
#include <stdio.h>

int main() {
    short s = 10;
    int i = s; //直接将s的值传递给i即可，但是注意此时s和i的类型不同
    return 0;
}
```
自动类型转换就是编译器隐式地进行的数据类型转换，这种转换不需要我们做什么，我们直接写就行，会自动进行转换操作。